<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Maze Escape</title>
<style>
  :root {
    --bg:#0e0f12; --panel:#171a21; --accent:#00e689; --danger:#ff5468; --text:#e9eef5; --muted:#9aa4b2; --gold:#ffc857;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
  html,body{margin:0; height:100%; background:var(--bg); color:var(--text); font-family:system-ui,Segoe UI,Roboto,sans-serif;}
  #wrap{position:fixed; inset:0; display:grid; grid-template-rows:1fr auto;}
  #hud{
    position:fixed; top:0; left:0; right:0; display:flex; gap:10px; align-items:center; justify-content:space-between;
    padding:12px clamp(10px,3vw,18px); background:linear-gradient(180deg,rgba(0,0,0,.35),transparent 60%); z-index:5; user-select:none;
    font-weight:700;
  }
  .pill{background:rgba(255,255,255,.07); padding:8px 12px; border-radius:999px; display:flex; gap:8px; align-items:center;}
  .btn{border:0; border-radius:10px; padding:8px 12px; background:var(--panel); color:var(--text); font-weight:800; cursor:pointer;}
  .btn:active{transform:translateY(1px);}
  #canvas{width:100%; height:100%; display:block; background:#0c0f14;}
  #overlay{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:10;
    background:radial-gradient(1200px 800px at 50% -200px, rgba(255,255,255,.06), transparent 60%);
  }
  .card{
    width:min(560px,92vw); background:var(--panel); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:20px;
    box-shadow:0 20px 60px rgba(0,0,0,.45);
  }
  .card h1,.card h2{margin:6px 0 12px;}
  .row{display:flex; flex-wrap:wrap; gap:10px; align-items:center;}
  .actions{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;}
  .primary{background:var(--accent); color:#053; font-weight:900; border:0; border-radius:12px; padding:12px 16px; cursor:pointer;}
  .ghost{background:transparent; border:1px solid rgba(255,255,255,.2); color:var(--text); border-radius:12px; padding:12px 16px; cursor:pointer;}
  .note{color:var(--muted); font-size:14px;}
  #touchCtrl{
    position:fixed; inset:auto 0 0 0; display:grid; grid-template-columns:1fr 1fr; gap:8px;
    padding:10px clamp(10px,3vw,18px); z-index:6; pointer-events:none;
  }
  .tbtn{
    pointer-events:auto; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); color:var(--text);
    font-weight:800; border-radius:14px; padding:14px; text-align:center; user-select:none;
  }
  .tbtn:active{transform:scale(.98); background:rgba(255,255,255,.12);}
  @media (min-width:800px){#touchCtrl{display:none;}}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="canvas"></canvas>
  <div id="hud">
    <div class="pill">Ø§Ù„Ø²Ù…Ù†: <span id="time">60.0</span>s</div>
    <div class="pill">Ø§Ù„Ø®Ø·ÙˆØ§Øª: <span id="steps">0</span></div>
    <div class="row" style="gap:8px;">
      <button class="btn" id="pauseBtn">Ø¥ÙŠÙ‚Ø§Ù</button>
      <button class="btn" id="regenBtn">Ù…ØªØ§Ù‡Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
      <button class="btn" id="soundBtn">ØµÙˆØª: ØªØ´ØºÙŠÙ„</button>
    </div>
  </div>
  <div id="touchCtrl">
    <div class="tbtn" id="leftBtn">â—€ ÙŠØ³Ø§Ø±</div>
    <div class="tbtn" id="rightBtn">ÙŠÙ…ÙŠÙ† â–¶</div>
  </div>
</div>

<div id="overlay">
  <div class="card" id="menu">
    <h1>ğŸ Maze Escape</h1>
    <div class="note">Ø§Ù‡Ø±Ø¨ Ù…Ù† Ø§Ù„Ù…ØªØ§Ù‡Ø© Ù‚Ø¨Ù„ Ù†ÙØ§Ø¯ Ø§Ù„ÙˆÙ‚ØªØŒ ÙˆØªØ¬Ù†Ø¨ Ø§Ù„Ø­Ø§Ø±Ø³ Ø§Ù„Ø°ÙŠ ÙŠØ·Ø§Ø±Ø¯Ùƒ!</div>
    <h2>Ø§Ù„ØªØ­ÙƒÙ…</h2>
    <ul>
      <li>Ø£Ø³Ù‡Ù… Ø§Ù„ÙƒÙŠØ¨ÙˆØ±Ø¯ Ø£Ùˆ Ø§Ù„Ø³Ø­Ø¨ (Swipe) Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø©</li>
      <li>Ø£Ø²Ø±Ø§Ø± Ù„Ù…Ø³ Ø³ÙÙ„ÙŠØ© Ù„Ù„ØªÙ†Ù‚Ù„ ÙŠÙ…ÙŠÙ†/ÙŠØ³Ø§Ø± (ÙˆØ§Ø³Ø­Ø¨ Ù„Ø£Ø¹Ù„Ù‰/Ù„Ø£Ø³ÙÙ„ Ù„Ù„ØªØ­Ø±ÙŠÙƒ Ø¹Ù…ÙˆØ¯ÙŠÙ‹Ø§)</li>
    </ul>
    <div class="row">
      <div class="pill">Ø£ÙØ¶Ù„ Ø²Ù…Ù†: <strong id="bestTime">0.0</strong>s</div>
      <div class="pill">Ø£Ù‚Ù„ Ø®Ø·ÙˆØ§Øª: <strong id="bestSteps">0</strong></div>
    </div>
    <div class="row">
      <div class="pill">Ø§Ù„Ø­Ø¬Ù…: <select id="sizeSel">
        <option value="S">ØµØºÙŠØ±</option>
        <option value="M" selected>Ù…ØªÙˆØ³Ø·</option>
        <option value="L">ÙƒØ¨ÙŠØ±</option>
      </select></div>
      <div class="pill">Ø§Ù„ÙˆÙ‚Øª: <select id="timeSel">
        <option>45</option><option selected>60</option><option>90</option>
      </select> s</div>
      <div class="pill">ØµØ¹ÙˆØ¨Ø© Ø§Ù„Ø­Ø§Ø±Ø³: <select id="guardSel">
        <option value="0.5">Ø³Ù‡Ù„</option>
        <option value="0.75" selected>Ù…ØªÙˆØ³Ø·</option>
        <option value="1">ØµØ¹Ø¨</option>
      </select></div>
    </div>
    <div class="actions">
      <button class="primary" id="startBtn">Ø§Ø¨Ø¯Ø£</button>
      <button class="ghost" id="resetBest">Ù…Ø³Ø­ Ø§Ù„Ø³Ø¬Ù„Ø§Øª</button>
    </div>
  </div>

  <div class="card" id="gameOver" style="display:none;">
    <h1 id="resultTitle">Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©</h1>
    <div class="row">
      <div class="pill">Ø§Ù„Ø²Ù…Ù†: <strong id="finalTime">0.0</strong>s</div>
      <div class="pill">Ø§Ù„Ø®Ø·ÙˆØ§Øª: <strong id="finalSteps">0</strong></div>
    </div>
    <div class="row" style="margin-top:8px;">
      <div class="pill">Ø£ÙØ¶Ù„ Ø²Ù…Ù†: <strong id="bestTime2">0.0</strong>s</div>
      <div class="pill">Ø£Ù‚Ù„ Ø®Ø·ÙˆØ§Øª: <strong id="bestSteps2">0</strong></div>
    </div>
    <div class="actions">
      <button class="primary" id="againBtn">Ø¬ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
      <button class="ghost" id="menuBtn">Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©</button>
    </div>
  </div>
</div>

<script>
(() => {
  // Elements
  const $ = s => document.querySelector(s);
  const canvas = $('#canvas'), ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });
  const hudTime = $('#time'), hudSteps = $('#steps');
  const pauseBtn = $('#pauseBtn'), regenBtn = $('#regenBtn'), soundBtn = $('#soundBtn');
  const overlay = $('#overlay'), menu = $('#menu'), gameOverCard = $('#gameOver');
  const startBtn = $('#startBtn'), againBtn = $('#againBtn'), menuBtn = $('#menuBtn'), resetBest = $('#resetBest');
  const bestTimeEl = $('#bestTime'), bestStepsEl = $('#bestSteps'), bestTime2 = $('#bestTime2'), bestSteps2 = $('#bestSteps2');
  const finalTimeEl = $('#finalTime'), finalStepsEl = $('#finalSteps'), resultTitle = $('#resultTitle');
  const sizeSel = $('#sizeSel'), timeSel = $('#timeSel'), guardSel = $('#guardSel');
  const leftBtn = $('#leftBtn'), rightBtn = $('#rightBtn');

  // Storage
  const store = {
    get(k,d){ try{return JSON.parse(localStorage.getItem(k)) ?? d;}catch{return d;}},
    set(k,v){ localStorage.setItem(k, JSON.stringify(v)); }
  };
  let BEST = store.get('maze_best', { time:0, steps:Infinity });
  let SOUND_ON = store.get('maze_sound', true);

  // Audio (WebAudio tones)
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioCtx();
  let audioUnlocked=false;
  function unlockAudio(){
    if(audioUnlocked) return;
    const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination); g.gain.value=0; o.start(); setTimeout(()=>o.stop(),10);
    audioUnlocked=true;
  }
  function beep(f=520, d=0.06, type='triangle', vol=0.08){
    if(!SOUND_ON) return;
    const o=audioCtx.createOscillator(), g=audioCtx.createGain();
    o.type=type; o.frequency.value=f; g.gain.value=vol; o.connect(g); g.connect(audioCtx.destination); o.start();
    setTimeout(()=>{ g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + d); }, 0);
    setTimeout(()=>o.stop(), d*1000+20);
  }
  function stepTone(){ beep(740, .02, 'square', .05); }
  function winTone(){ beep(880, .08, 'triangle', .08); setTimeout(()=>beep(1046,.08,'triangle',.08),90); }
  function loseTone(){ beep(200, .12, 'sawtooth', .1); }

  soundBtn.textContent = 'ØµÙˆØª: ' + (SOUND_ON ? 'ØªØ´ØºÙŠÙ„' : 'Ø¥ÙŠÙ‚Ø§Ù');
  soundBtn.addEventListener('click', ()=>{ SOUND_ON=!SOUND_ON; store.set('maze_sound',SOUND_ON); soundBtn.textContent='ØµÙˆØª: '+(SOUND_ON?'ØªØ´ØºÙŠÙ„':'Ø¥ÙŠÙ‚Ø§Ù'); if(SOUND_ON) beep(900,.05,'square',.04); });

  // Canvas sizing DPR
  function resize(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    const w = Math.floor(window.innerWidth), h = Math.floor(window.innerHeight);
    canvas.style.width = w+'px'; canvas.style.height = h+'px';
    canvas.width = Math.floor(w*dpr); canvas.height = Math.floor(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw(); // redraw if paused/menu
  }
  window.addEventListener('resize', resize, { passive:true });

  // Maze data
  let cols=21, rows=21, cell=28, pad=16;
  let grid, visited;
  let start = {c:0,r:0}, exit = {c:0,r:0};
  let player = {c:0,r:0, steps:0};
  let guard = {c:0,r:0, tick:0};
  let running=false, paused=false, ended=false;
  let timeLeft=60, baseTime=60, guardSpeed=0.75; // steps per second
  let lastTS=performance.now();

  function pickSize(){
    const W = window.innerWidth, H = window.innerHeight;
    const mode = sizeSel.value; // S, M, L
    const targetCell = (mode==='S')?32:(mode==='M')?28:24;
    cell = Math.max(20, Math.min(40, targetCell));
    pad = Math.round(cell*0.6);
    const maxCols = Math.floor((W - pad*2) / cell);
    const maxRows = Math.floor((H - pad*2) / cell);
    // keep odd to have perfect maze ring
    cols = Math.max(11, (maxCols%2?maxCols:maxCols-1));
    rows = Math.max(11, (maxRows%2?maxRows:maxRows-1));
    // limit upper bounds for perf
    cols = Math.min(cols, (mode==='L')?43:(mode==='M')?35:27);
    rows = Math.min(rows, (mode==='L')?43:(mode==='M')?35:27);
  }

  // Maze generation: Recursive backtracker
  function idx(c,r){ return r*cols + c; }
  function genMaze(){
    grid = new Array(cols*rows).fill(0); // bit flags: 1=up,2=right,4=down,8=left (openings)
    visited = new Array(cols*rows).fill(false);
    function neighbors(c,r){
      const list = [];
      if(r>0) list.push([c,r-1,'U']);
      if(c<cols-1) list.push([c+1,r,'R']);
      if(r<rows-1) list.push([c,r+1,'D']);
      if(c>0) list.push([c-1,r,'L']);
      for(let i=list.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [list[i],list[j]]=[list[j],list[i]]; }
      return list;
    }
    function carve(c,r){
      visited[idx(c,r)] = true;
      for(const [nc,nr,dir] of neighbors(c,r)){
        if(visited[idx(nc,nr)]) continue;
        if(dir==='U'){ grid[idx(c,r)] |= 1; grid[idx(nc,nr)] |= 4; }
        if(dir==='R'){ grid[idx(c,r)] |= 2; grid[idx(nc,nr)] |= 8; }
        if(dir==='D'){ grid[idx(c,r)] |= 4; grid[idx(nc,nr)] |= 1; }
        if(dir==='L'){ grid[idx(c,r)] |= 8; grid[idx(nc,nr)] |= 2; }
        carve(nc,nr);
      }
    }
    // start at odd cell near top-left
    const sc = 1, sr = 1;
    carve(sc,sr);
    start = { c:1, r:1 };
    exit = farthestCellFrom(start);
  }

  // BFS to find farthest cell (as exit)
  function farthestCellFrom(src){
    const q = [[src.c,src.r]], dist = new Map();
    dist.set(idx(src.c,src.r), 0);
    let best=[src.c,src.r,0];
    while(q.length){
      const [c,r]=q.shift(); const d=dist.get(idx(c,r));
      if(d>best[2]) best=[c,r,d];
      const mask=grid[idx(c,r)];
      if(mask&1){ const nr=r-1; if(!dist.has(idx(c,nr))){ dist.set(idx(c,nr), d+1); q.push([c,nr]); } }
      if(mask&2){ const nc=c+1; if(!dist.has(idx(nc,r))){ dist.set(idx(nc,r), d+1); q.push([nc,r]); } }
      if(mask&4){ const nr=r+1; if(!dist.has(idx(c,nr))){ dist.set(idx(c,nr), d+1); q.push([c,nr]); } }
      if(mask&8){ const nc=c-1; if(!dist.has(idx(nc,r))){ dist.set(idx(nc,r), d+1); q.push([nc,r]); } }
    }
    return { c:best[0], r:best[1] };
  }

  // Drawing
  function drawCellRect(c,r,fill,stroke){
    const x = pad + c*cell, y = pad + r*cell;
    if(fill){ ctx.fillStyle=fill; ctx.fillRect(x+1,y+1,cell-2,cell-2); }
    if(stroke){ ctx.strokeStyle=stroke; ctx.strokeRect(x+0.5,y+0.5,cell-1,cell-1); }
  }
  function drawMaze(){
    // background
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0, '#0f1420'); g.addColorStop(1, '#0a0d14');
    ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);

    // outer frame
    const W = pad*2 + cols*cell, H = pad*2 + rows*cell;
    const ox = Math.max(0, (canvas.width - W)/2), oy = Math.max(0, (canvas.height - H)/2);
    ctx.save(); ctx.translate(ox, oy);

    // shadow panel
    ctx.fillStyle = '#0b0f15';
    ctx.fillRect(pad-6,pad-6, cols*cell+12, rows*cell+12);

    // cells with paths
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#1a2331';
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        ctx.strokeRect(pad + c*cell, pad + r*cell, cell, cell);
      }
    }

    // carve walls by drawing passages
    ctx.fillStyle = '#121826';
    ctx.fillRect(pad, pad, cols*cell, rows*cell);

    ctx.strokeStyle = '#283447';
    ctx.lineWidth = Math.max(2, Math.floor(cell*0.12));
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const m = grid[idx(c,r)];
        const x = pad + c*cell, y = pad + r*cell;
        // draw walls (we'll "erase" openings by overlaying dark fill)
        // Instead: draw walls around cells where passage missing
        ctx.beginPath();
        // up
        if(!(m&1)){ ctx.moveTo(x,y); ctx.lineTo(x+cell,y); }
        // right
        if(!(m&2)){ ctx.moveTo(x+cell,y); ctx.lineTo(x+cell,y+cell); }
        // down
        if(!(m&4)){ ctx.moveTo(x,y+cell); ctx.lineTo(x+cell,y+cell); }
        // left
        if(!(m&8)){ ctx.moveTo(x,y); ctx.lineTo(x,y+cell); }
        ctx.stroke();
      }
    }

    // exit cell
    drawCellRect(exit.c, exit.r, 'rgba(0,230,137,0.18)');
    ctx.strokeStyle = 'rgba(0,230,137,0.6)';
    ctx.lineWidth = 2; ctx.strokeRect(pad + exit.c*cell+2, pad + exit.r*cell+2, cell-4, cell-4);

    // player
    const px = pad + player.c*cell + cell*0.2, py = pad + player.r*cell + cell*0.2;
    const ps = cell*0.6;
    ctx.fillStyle = '#2fff7f';
    roundRect(ctx, px, py, ps, ps, Math.max(4,cell*0.15)); ctx.fill();

    // guard
    const gx = pad + guard.c*cell + cell*0.2, gy = pad + guard.r*cell + cell*0.2;
    ctx.fillStyle = '#ff5468';
    roundRect(ctx, gx, gy, ps, ps, Math.max(4,cell*0.15)); ctx.fill();

    ctx.restore();
  }
  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawMaze();
  }

  // Input: keyboard + swipe + on-screen
  let keyUp=false,keyDown=false,keyLeft=false,keyRight=false;
  document.addEventListener('keydown', (e)=>{
    if(e.key==='ArrowUp' || e.key==='w') keyUp=true;
    if(e.key==='ArrowDown' || e.key==='s') keyDown=true;
    if(e.key==='ArrowLeft' || e.key==='a') keyLeft=true;
    if(e.key==='ArrowRight' || e.key==='d') keyRight=true;
    if(e.key===' ' || e.key==='Enter'){ if(!running){ startGame(); } else togglePause(); }
  });
  document.addEventListener('keyup', (e)=>{
    if(e.key==='ArrowUp' || e.key==='w') keyUp=false;
    if(e.key==='ArrowDown' || e.key==='s') keyDown=false;
    if(e.key==='ArrowLeft' || e.key==='a') keyLeft=false;
    if(e.key==='ArrowRight' || e.key==='d') keyRight=false;
  });

  let swipeStart=null;
  canvas.addEventListener('pointerdown', (e)=>{ unlockAudio(); swipeStart={x:e.clientX,y:e.clientY}; });
  window.addEventListener('pointerup', ()=>{ swipeStart=null; });
  window.addEventListener('pointermove', (e)=>{
    if(!swipeStart) return;
    const dx=e.clientX - swipeStart.x, dy=e.clientY - swipeStart.y;
    const absx=Math.abs(dx), absy=Math.abs(dy);
    if(absx>24 || absy>24){
      if(absx>absy){ if(dx>0) tryMove(1,0); else tryMove(-1,0); }
      else { if(dy>0) tryMove(0,1); else tryMove(0,-1); }
      swipeStart={x:e.clientX,y:e.clientY};
    }
  }, {passive:true});

  // quick on-screen for horizontal moves; vertical via swipe
  leftBtn.addEventListener('pointerdown', ()=>tryMove(-1,0));
  rightBtn.addEventListener('pointerdown', ()=>tryMove(1,0));

  // Movement
  let moveCooldown=0.0; // seconds between moves if holding keys
  function tryMove(dc,dr){
    if(!running || paused || ended) return;
    const m = grid[idx(player.c,player.r)];
    if(dr===-1 && !(m&1)) return; // up blocked
    if(dc===1 && !(m&2)) return; // right blocked
    if(dr===1 && !(m&4)) return; // down blocked
    if(dc===-1 && !(m&8)) return; // left blocked
    player.c += dc; player.r += dr; player.steps++;
    hudSteps.textContent = String(player.steps);
    stepTone();
    // check exit
    if(player.c===exit.c && player.r===exit.r){ doWin(); }
  }

  // Guard AI: greedy step toward player, respecting walls
  function guardStep(){
    const options = [];
    const gm = grid[idx(guard.c,guard.r)];
    const target = {c:player.c, r:player.r};
    // up
    if(gm&1) options.push({dc:0,dr:-1, score:heur(guard.c,guard.r-1,target)});
    // right
    if(gm&2) options.push({dc:1,dr:0, score:heur(guard.c+1,guard.r,target)});
    // down
    if(gm&4) options.push({dc:0,dr:1, score:heur(guard.c,guard.r+1,target)});
    // left
    if(gm&8) options.push({dc:-1,dr:0, score:heur(guard.c-1,guard.r,target)});
    options.sort((a,b)=>a.score-b.score);
    if(options.length){
      guard.c += options[0].dc; guard.r += options[0].dr;
    }
  }
  function heur(c,r,target){ // Manhattan
    return Math.abs(c - target.c) + Math.abs(r - target.r);
  }

  // Loop
  function loop(ts){
    if(!running) return;
    requestAnimationFrame(loop);
    if(paused || ended) return;
    let dt = (ts - lastTS)/1000; if(dt>0.05) dt=0.05; lastTS=ts;

    // held keys movement cooldown
    moveCooldown -= dt;
    if(moveCooldown<=0){
      if(keyUp) { tryMove(0,-1); moveCooldown=0.12; }
      else if(keyDown){ tryMove(0,1); moveCooldown=0.12; }
      else if(keyLeft){ tryMove(-1,0); moveCooldown=0.12; }
      else if(keyRight){ tryMove(1,0); moveCooldown=0.12; }
    }

    // time
    timeLeft -= dt;
    if(timeLeft<=0){ timeLeft=0; doLose('Ù†ÙØ¯ Ø§Ù„ÙˆÙ‚Øª'); }
    hudTime.textContent = timeLeft.toFixed(1);

    // guard move rate
    guard.tick += dt * guardSpeed; // speed scales by difficulty
    if(guard.tick>=0.25){ guard.tick=0; guardStep(); }

    // caught?
    if(guard.c===player.c && guard.r===player.r){ doLose('Ø§Ù„Ø¥Ù…Ø³Ø§Ùƒ Ø¨Ùƒ'); }

    draw();
  }

  // Lifecycle
  function resetGame(){
    pickSize();
    // center maze panel inside canvas: adjust pad if needed (kept as padding margin)
    player.steps=0; hudSteps.textContent='0';
    baseTime = parseInt(timeSel.value,10) || 60;
    timeLeft = baseTime;
    guardSpeed = parseFloat(guardSel.value)||0.75;
    genMaze();
    player.c=start.c; player.r=start.r;
    // place guard at farthest from player (near exit)
    guard = { c: exit.c, r: exit.r, tick:0 };
    ended=false; paused=false;
  }

  function startGame(){
    audioCtx.resume().catch(()=>{});
    unlockAudio();
    overlay.style.display='none';
    running=true; paused=false; ended=false;
    lastTS = performance.now();
    resetGame();
    resize();
    requestAnimationFrame(loop);
  }

  function doWin(){
    ended=true; running=false; winTone();
    const tUsed = (baseTime - timeLeft);
    // best time: Ø£Ø¹Ù„Ù‰ Ù‚ÙŠÙ…Ø© Ø²Ù…Ù† ØªÙ… Ø¥Ù†Ø¬Ø§Ø²Ù‡ Ø¨Ø³Ø±Ø¹Ø© Ø£ÙƒØ¨Ø± (Ù†Ù‚ÙŠØ³ Ø§Ù„Ø£Ù‚ØµØ± Ø²Ù…Ù†Ù‹Ø§ Ù„Ù„Ø¥Ù†Ù‡Ø§Ø¡)
    if(BEST.time===0 || tUsed < BEST.time) BEST.time = tUsed;
    if(player.steps < (BEST.steps||Infinity)) BEST.steps = player.steps;
    store.set('maze_best', BEST);
    finalTimeEl.textContent = tUsed.toFixed(1);
    finalStepsEl.textContent = String(player.steps);
    bestTime2.textContent = (BEST.time||0).toFixed(1);
    bestSteps2.textContent = String(BEST.steps||0);
    resultTitle.textContent = 'ÙØ²Øª!';
    showGameOver();
  }

  function doLose(reason){
    if(ended) return;
    ended=true; running=false; loseTone();
    finalTimeEl.textContent = (baseTime - timeLeft).toFixed(1);
    finalStepsEl.textContent = String(player.steps);
    bestTime2.textContent = (BEST.time||0).toFixed(1);
    bestSteps2.textContent = String(BEST.steps||0);
    resultTitle.textContent = 'Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø© - ' + reason;
    showGameOver();
  }

  function showMenu(){
    overlay.style.display='flex';
    menu.style.display=''; gameOverCard.style.display='none';
    bestTimeEl.textContent = (BEST.time||0).toFixed(1);
    bestStepsEl.textContent = String(BEST.steps===Infinity?0:BEST.steps||0);
  }
  function showGameOver(){
    overlay.style.display='flex';
    menu.style.display='none'; gameOverCard.style.display='';
  }
  function togglePause(){
    if(!running || ended) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Ø§Ø³ØªØ¦Ù†Ø§Ù' : 'Ø¥ÙŠÙ‚Ø§Ù';
    if(!paused) lastTS = performance.now();
  }

  // Buttons
  startBtn.addEventListener('click', ()=>{ startGame(); });
  againBtn.addEventListener('click', ()=>{ startGame(); });
  menuBtn.addEventListener('click', ()=>{ showMenu(); });
  resetBest.addEventListener('click', ()=>{ BEST={time:0,steps:Infinity}; store.set('maze_best',BEST); bestTimeEl.textContent='0.0'; bestStepsEl.textContent='0'; });
  pauseBtn.addEventListener('click', ()=>togglePause());
  regenBtn.addEventListener('click', ()=>{ if(!running) return; resetGame(); });
  window.addEventListener('visibilitychange', ()=>{ if(document.hidden) paused=true; pauseBtn.textContent='Ø§Ø³ØªØ¦Ù†Ø§Ù'; });

  // Init
  showMenu();
  resize();
})();
</script>
</body>
</html>
